# HTML to StrongHelp Perl script
# © Alex Waugh 1999
# Version 0.01 13/11/99
# $Revision: 1.5 $

#Default files to use - can be overridden by command line arguments
$tempdir="temp";
$infile="index.html";
$outfile="$tempdir/!root";

#Only process files with the following file extensions or no extension
#You can add or remove extensions from the list
@fileextensions=(
		".shtml",
		".html",
		".htm",
);

#Filenames to treat as default pages
@renametoroot=(
		"index.shtml",
		"index.html",
		"index.htm",
);

#A list of what tags and how to replace them
#To stop a tag from being processed add a # character to the beggining of the appropriate line
#Tags with a single * are processed further by the replace subroutine
%options=(
		"i"		=> "{/}",
		"/i"		=> "{/}",
		"b"		=> "{*}",
		"/b"		=> "{*}",
		"strong"	=> "{*}",
		"/strong"	=> "{*}",
		"em"		=> "{/}",
		"/em"		=> "{/}",
		"h1"		=> "\n\n{fh1}",
		"h2"		=> "\n\n{fh2}",
		"h3"		=> "\n\n{fh3}",
		"h4"		=> "\n\n{fh4}",
		"h5"		=> "\n\n{fh5}",
		"h6"		=> "\n\n{fh6}",
		"/h1"		=> "{f}\n",
		"/h2"		=> "{f}\n",
		"/h3"		=> "{f}\n",
		"/h4"		=> "{f}\n",
		"/h5"		=> "{f}\n",
		"/h6"		=> "{f}\n",
		"title"		=> "",
		"/title"	=> "\n",
		"br"		=> "\n",
		"hr"		=> "{line}",
		"ol"		=> "{indent +1}\n",
		"ul"		=> "{indent +1}\n",
		"li"		=> "\n",
		"/ol"		=> "{indent}",
		"/ul"		=> "{indent}",
		"pre"		=> "{fcode}",
		"/pre"		=> "{f}",
#		""		=> "",
		"center"	=> "{align centre}",
		"/center"	=> "{align}",
		"a"		=> "*",
		"/a"		=> "*",
		"p"		=> "*",
		"/p"		=> "*",
	);

#A list of named characters and their replacements
#To stop a character from being processed add a # character to the beggining of the appropriate line
%chars=(
		"&lt;"		=> "\\<",
		"&gt;"		=> ">",
		"&amp;"		=> "&",
		"&quot;"	=> "\"",
		"&nbsp;"	=> " ",
		"&pound;"	=> "£",
#		""		=> "",
#		""		=> "",
	);

#Munge Unixy filenames into a suitable form for RISC OS
sub munge {
	my ($filename)=$_[0];
	$filename=~s/\.\./\^/g;
	$filename=~s/^\.\///g;
	$filename=~s/\//|/g;
	$filename=~s/\./\//g;
	$filename=~s/\|/\./g;
	return $filename;
}

#Replace a named character with its value
sub getnamedchar {
	my ($charname)=@_;
	return $charname if not exists $chars{$charname};
	return $chars{$charname};
}

#Replace a HTML tag with a suitable StrongHelp tag
sub replace {
	my ($wholetag,$tagtype,%attributes)=@_;
	#Remove all unknown tags
	return "" if not defined $options{$tagtype};
	#Return replacement tag if a simple translation is possible
	return $options{$tagtype} if $options{$tagtype} ne "*";
	#More complex processing must be needed
	if ($tagtype eq "a") {
		$link="";
		if (exists $attributes{"href"}) {
			$link=$attributes{"href"};
			#Check for external links
			if ($link=~m/^(http:)|(https:)|(ftp:)|(mailto:)|(gopher:)|(news:)|(telnet:)|(finger:)/i) {
				$link="=>#URL $link>";
			#Check for in-document links
			} elsif ($link=~m/^\#(.*)/) {
				$link="=>#TAG $1>";
			#Must be a relative file link
			} else {
				$link=$prefix.$link;
				$old=$link;
				$link=~s/\/$/\/!root/;
				while ($link=~s/([^\/\.])+\/\.\.\///) {};
				$link=~s/^\.\///;
				$link=~s/[^\.]+\.\///g;
				print "$old\n$link\n" if $old ne $link;
				push @files,$link;
				foreach (@renametoroot) {$link=~s/$_$/!Root/;}
				$link=munge($link);
				$link="=>$link>";
			}
			return "<";
		} elsif (exists $attributes{"name"}) {
			return "{tag $attributes{'name'}}";
		}
		return "";
	} elsif ($tagtype eq "/a") {
		return $link;
	} elsif ($tagtype eq "p") {
		$ret="\n\n";
		#Only add an alignment tag if alignment is different from previous paragraph
		if (lc($attributes{"align"}) ne $align) {
			$ret=$ret."{align";
			if (lc($attributes{"align"}) eq "center") {
				$ret=$ret." centre}";
				$align="center";
			} elsif (lc($attributes{"align"}) eq "right") {
				$ret=$ret." right}";
				$align="right";
			} else {
				$ret=$ret."}";
				$align="left";
			}
		}
		return $ret;
	} elsif ($tagtype eq "/p") {
		return "{align}" if $align ne "left";
		return "";
	} else {
		return "";
	}
}

#Get all the attribute fields of the HTML tag and give them to sub replace as an array
sub getattr {
	my ($wholetag,$tagtype,$attributes)=@_;
	my (%attributes);
	my ($wholetemp)=$wholetag;
	while (($wholetemp=~s/(\w+)=(("([^"]*)")|(\w+))//i)) {
		$attributes{lc($1)}=$4.$5;
	}
	return replace($wholetag,lc $tagtype,%attributes);
}

#Process the file passed as an argument
sub processfile {
	my ($infile,$outfile)=@_;
	$outfile="$tempdir/$infile" if not defined $outfile;
	my ($found)=0;
        #Remove any tag after the filename
        $infile=~s/([^#]*)#.*/$1/;
	#Check for a suitable file extension (so we dont process .zip files or images etc.)
	my ($temp)=$infile;
	foreach (@fileextensions) {
		$found=1 if $temp=~m/$_$/;
	}
	#If it does not have a suitable extension, check to see if it has no extension
	$found=not $temp=~m/[^\/]*\.[^\/]*$/ if not $found;
	if (not $found) {
		print "Ignoring file $infile: wrong file extension\n";
		return;
	}
	#Rename indexes to !Roots
	foreach (@renametoroot) {$outfile=~s/$_$/!Root/;}
	#Check that we have not already processed this file
	return if -e $outfile;
	#Check we can find the file
	if (not -e $infile) {
		print "Cannot find file $infile, skipping\n";
		return;
	}
	print "Processing file $infile...\n";
	#Create any subdirectories needed
	$temp=$outfile;
	undef @temp;
	while ($temp=~s/(.*)\/[^\/]*$/$1/) { push @test,$1 };
	while (@test) {
		$dir=munge(pop @test);
		system "cdir $dir";
	}
	#Get the pathname (without leafname) for this file
	$infile=~m/(.*\/)[^\/]*$/;
	$prefix=$1;
	open("out",">".$outfile) or die "Can't create $outfile: $!\n";
	open($handle,$infile);
	while (<$handle>) {
		#Remove excess whitespace (except when enclosed by <pre>...</pre> tags)
		s/(((<pre>).*(<\/pre>){1}?)*)\n(((<pre>).*(<\/pre>){1}?)*)/$1 $5/sig;
		s/(((<pre>).*(<\/pre>){1}?)*)\t(((<pre>).*(<\/pre>){1}?)*)/$1 $5/sig;
		s/(((<pre>).*(<\/pre>){1}?)*)  (((<pre>).*(<\/pre>){1}?)*)/$1 $5/sig;
		#Replace tags
		s/(<(\s*|!\W*)(\/?\w+)([^<>]*)>)/getattr($1,$3,$4)/eig;
		#Remove more excess whitespace
		while (s/\n\n\n/\n\n/) {}
		s/^ +//mg;
		s/^({[^{}]*}) +/$1/mg;
		#Replace named characters
		s/(\&\w+\;)/getnamedchar($1)/eig;
		print out;
	}
	close out;
	print "Finshed processing $infile\n";
}

#Read in whole file in one go - removes problems with tags spanning more than one line
undef $/;

#Read command line arguments (if any)
$infile=$ARGV[0] if $ARGV[0] ne "";
$outfile=$ARGV[1] if $ARGV[1] ne "";

$align="left";
$handle="currentfile";

#Check StrongHelp is loaded
system "Set HTML2SH$Found 0";
system "RMEnsure StrongHelp 2.70 Set HTML2SH$Found 2";
system "RMEnsure StrongHelp 2.20 Set HTML2SH$Found 1";
die "Please load StrongHelp 2.20 or later and try again\n" if $ENV{"HTML2SH$Found"} eq "1";
print "You do not have the latest version of StrongHelp, I suggest you upgrade\n" if $ENV{"HTML2SH$Found"} eq "2";
system "Unset HTML2SH$Found";

#Create temporary directory
system "cdir $tempdir";

#Process the main file
processfile($infile);
while (@files) {
	#Process any file linked to from main file
	processfile(pop @files);
}
print "All files processed\n";
print "Creating manual...\n";
system "StrongCreate Manual";
system "copy $tempdir.* Manual.* ~C~DF~L~N~P~QR~S~TV";
print "Manual created\n";
system "Filer_Run Manual";
